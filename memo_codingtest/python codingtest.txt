여러개 입력 받는 형식

n, k, m을 입력받아야 하면

n, m, k = map(int, input().split())
n = int(input())
count = count + n  이거는 count += n 이거랑 같음

list 
=> names = [ 100, 200, 300 ]
print(names)
print(names[0])
print(names[1])
print(names[2])
이런 식

ex) random = list(map(int, input().split()))

오름차순 정렬은 random.sort() 이렇게!
내림차순 정렬은 random.sort(reverse = True)

* 반복문 ( 무한루프 ) -> while(True)
어떤 조건이 나오기 전까지 계속해서 입력을 받기 위해서는 
while True: 를 쓰면 될 것 같다. (*백준 10952번)
while의 무한루프라는 특성을 이용해서 while True:로 무한루프를 만들고 if라는 조건을 걸어 그 조건에 해당하면 break하도록 하면 될 것 같다.

# break
break를 사용하면 전체 반복문을 빠져 나오게 된다.

# continue
continue를 만나면 그 아래 코드를 수행하지 않고 다시 조건을 판단하는 곳으로 돌아온다.



* test case의 경우가 주어지지 않는 경우
try - except를 써서 나타낸다. (*백준 10951번)
(*10951번 같은 경우 int값으로 받기 때문에 int값 외의 정보들이 들어오게 되면 문제가 생긴다.)
try - except의 경우 파이썬에서 구문 오류가 발생할 때 해결할 수 있는 코드이다. 
프로그램 중에는 사용자가 무엇인가를 입력해야 하는 경우 에러가 발생할 가능성이 있다. 
숫자를 입력해야 하는데 문자를 입력한다던가 실수를 입력해야 하는데 정수를 입력하는 등이 그런 예이다.
백준 알고리즘 문제에서는 잘못 입력될 가능성이 없기 때문에 구문 오류에 대해 고려하지 않고 문제를 풀고 있지만 여러 가지 에러로 인해 프로그램이 실행되지 않을 수가 있다.
이러한 에러가 발생할 여지가 있는 경우에 try - except 구문을 이용하면 에러가 발생돼도 프로그램이 멈추지 않고 계속 진행될 수 있도록 만들 수 있다.

# iterable 객체와 iterator 객체 비교
iterable 객체
iterable 객체 - 반복 가능한 객체
대표적으로 iterable한 타입 - list, dict, set, str, bytes, tuple, range
19. for in 반복문, Range, enumerate 에서 iterable한 타입과 iterable한 타입을 확인하는 방법이 있습니다.

iterator 객체
iterator 객체 - 값을 차례대로 꺼낼 수 있는 객체입니다.
iterator는 iterable한 객체를 내장함수 또는 iterable객체의 메소드로 객체를 생성할 수 있습니다.
파이썬 내장함수 iter()를 사용해 iterator 객체를 만들어봅니다. REPL을 실행합니다.


# append와 extend 그리고 insert
https://ooyoung.tistory.com/117
append
array.append(x) 형태로 사용한다. 
append는 덧붙인다는 뜻으로 괄호( ) 안에 값을 입력하면 새로운 요소를 array 맨 끝에 객체로 추가한다.
요소를 추가할 때는 객체로 추가하게 되는데, 입력한 값이 리스트와 같은 반복 가능한 iterable 자료형이더라도 객체로 저장한다. 사용 예시는 아래와 같다.
append 함수를 사용해서 array의 맨 끝에 요소로 추가되었다.
두 번째 예시의 경우 [5, 6]이라는 리스트를 추가하였는데 각 값이 5, 6의 요소로 추가되는 것이 아니라 [5, 6]이라는 리스트 형태가 그대로 요소로 추가된 것을 볼 수 있다. 

extend
array.extend(iterable) 형태로 사용한다.
입력한 iterable 자료형의 항목 각각을 array의 끝에 하나씩 추가한다.
append와 동일하게 요소를 array의 끝에 추가하지만 append와 다른 점은 괄호( ) 안에는 iterable 자료형만 올 수 있다는 것이다.
iterable 자료형이 아닌 경우 TypeError가 발생한다. 사용 예시는 아래와 같다.
괄호 안에 iterable 자료형만 입력할 수 있기 때문에 요소 하나를 추가하려면 리스트와 같은 iterable 자료형으로 변환하여 입력해야 한다.
그런데 요소 하나만 추가한다면 굳이 extend 함수를 사용하기보다는 append 함수를 사용하는 것이 편리하겠다.
반면 append 함수는 iterable 자료형의 요소를 각각 추가하는 것이 불가능하니 그럴 때는 extend 함수를 사용할 수 있겠다.

insert
array.insert(i, x) 형태로 사용한다. array의 원하는 위치 i 앞에 추가할 값 x를 삽입할 수 있다.
i는 위치를 나타내는 인덱스를 숫자를 입력한다. 음수를 입력하면 배열의 끝을 기준으로 처리된다.
추가할 값 x는 객체로 추가되며 iterable 자료형이더라도 객체로 저장된다. 사용 예시는 아래와 같다.
array의 끝에 추가하고 싶은 경우 array의 요소 개수가 적으면 하나하나 셀 수도 있지만 요소가 많은 경우 len( ) 함수를 이용할 수 있다.
위에서 생성한 nums 변수에 대해서 맨 마지막에 요소를 추가하는 경우는 아래 코드에서 작성해보았다.

세 개의 함수 비교 정리
1) append 함수
arry.append(x) 형태로 사용한다. x를 arry의 맨 끝에 객체로 추가다. x가 iterable 자료형이더라도 전체를 하나의 객체로 해서 요소로 추가한다.
2) extend 함수
array.extend(iterable) 형태로 사용한다. iterable의 각 요소를 하나씩 array의 끝에 요소로 추가한다.
append 함수와 다른 점은 괄호 안에 iterable 자료형만 올 수 있다.
3) insert 함수
array.insert(i, x) 형태로 사용한다. 원하는 위치 i에 x를 삽입할 수 있다. 값 x는 객체로 추가된다.
append 함수와 마찬가지로 iterable 자료형이더라도 하나의 요소로 삽입된다.

#  백준 2562번
a = []
for i in range(9):
    a.append(int(input()))
print(max(a))
print(a.index(max(a))+1)

이거 기억하자. append와 리스트, index, max 값들을 다양하게 자유자재로 사용할 수 있어야 한다.

# 이것이 코딩테스트다 - 그리드 - 큰 수의 법칙
반복 되는 수열이 있으면 그것을 먼저 파악해야 한다.

# 구현 : 프로그래밍 언어의 문법을 정확하게 알고 있어야 한다.
완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

# 백준 3052번 => 중복되는 요소를 제거할 때 set() 함수 사용 : 여기서는 자료형의 중복을 제거하기 위해 set 함수를 사용했다. 

nums = set()  # 중복되는 요소를 제거
for _ in range(10):
    i = int(input())
    nums.add(i%42)  # 집합자료형에 원소를 추가할 때 add 함수를 사용

print(len(nums))

또는

n = []

for _ in range(10):
    a = int(input())
    b = a % 42
    n.append(b)

s = set(n)
print(len(s))

또는   (이게 제일 좋은 듯)

arr = []
for i in range(10):
    n = int(input())
    arr.append(n % 42)
arr = set(arr)
print(len(arr))

1. 빈 배열을 만들고 2. 그 안에 값을 넣은 다음 3. 42로 나눈 값을 다시 넣는다 4. 중복된 값 제거한다.

len() : 리스트에 들어 있는 원소 개수, 즉 리스트의 크기를 알려준다.


append와 extend에 


----

if:
elif:
else:
이다. 
