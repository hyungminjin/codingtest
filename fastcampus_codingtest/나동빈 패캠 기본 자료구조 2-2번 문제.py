test_case = int(input())
# test_case

for _ in range(test_case):
    n,m  = list(map(int, input().split(' ')))
    queue = list(map(int, input.split(' ')))
    queue = [queue(i, idx) for idx, i in enumerate(queue)]  # (간단한 트릭)

    count = 0
    while True: ## 여기서부터 무한 반복 시작 (어떤 것을 하느냐!)
        if queue[0][0] == max(queue, key = lambda x: x[0][0]): # queue에 가장 앞쪽에 있는 원소를 확인해서 그 원소의 중요도가 
            # 그 queue에서의 가장 큰 중요도와 동일하다면, 즉 가장 중요도가 높은 문서가 가장 앞쪽에 위치해 있다면 
            count += 1 # 카운트 증가
            if queue [0][1] == m: # 뽑은 문서가 찾고자 하는 문서인 m이었다면 (튜플의 2번째 원소인 번호가 우리가 설정한 번호와 같다면)
                print(count)
                break

            else:
                queue.pop(0) # m이 아니라면 뽑기하면 된다.

        else:
            queue.append(queue.pop(0)) # 설정했을 때 가장 중요도가 높은 문서가 아니라면 그 문서를 보내기 위해 문서를 pop한다.


#    queue에 들어가 있는 데이터는 그냥 단순하게 넣게 되면 실질적으로 우리가 알고리즘을 구현함에 있어서 약간 어려움이 있기 때문에 간단한 트릭을 사용한다.
# (간단한 트릭)
# enumerate를 사용하면 수열리스트를 받게 되었을 때 각각 튜플의 형태로 받아주게 된다.
# enumerate은 특정한 리스트를 각각 index랑 같이 파악할 수 있게 해준다.
# 그 index를 튜플의 2번째 원소로 선정하게 되면
# ex)예시로 4 2
# [2, 1, 4, 3] => [(2,0),(1,1),(4,2),(3,3)] 이런 식으로 리스트가 만들어진다.
# 그리고 이게 다시 queue에 들어갈 수 있도록 하는 것이다.

### 튜플 형태로 묶어주면 좋은 점이 있다.
##=> 가장 큰 값을 구하거나 혹은 정렬하거나 이런 값들이 정말 쉽게 이루어진다는 것이다. [즉 그런 문제들은 튜플을 이용해보면 좋을 것이다.]
# 리스트가 append와 pop 연산을 가지고 있기 때문에 큐처럼 연산을 하는 것이다.
# 가장 앞쪽에 있는 문서를 확인한 다음 중요도가 가장 높은 문서라면 뽑으면 된다. 뽑은 문서가 우리가 찾고자 하는 m문서라면 정답을 찾으면 된다.
# 앞 쪽에 있지 않다면 뒤쪽으로 보내면 된다.
####============================================================####

## 키로거 - 스택, 구현, 그리디 - / 