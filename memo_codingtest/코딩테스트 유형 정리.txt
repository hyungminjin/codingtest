모든 경우의 수를 다 따져 봐야 하는 경우 -> 완전 탐색 유형으로 분류 된다.
완전 탐색 알고리즘은 가능한 경우의 수를 모두 검사해보는 방법이다.
구현이 중요한 대표적인 문제 유형이다. 
일반적으로 완전 탐색 알고리즘은 비효율적인 시간 복잡도를 가지고 있으므로 데이터 개수가 큰 경우에 정상적으로 작동하지 않을 수 있다. 
탐색해야할 전체 데이터 개수가 100만 개 이하일 때 완전 탐색을 사용하면 적절하다.

구현문제 유형은 그리디 알고리즘 문제 유형과 비교했을 때 큰 차이가 없을 수 있다. 하나의 문제에 구현 유형과 그리디 유형이 함께 포함된 형태로 출제되는 경우가 많다. 

# n, m = map(int, input().split())

# def today(n, m):
#     print(str(n)+'월'+str(m)+'일')

# today(n,m)

# n = list(map(int, input().split()) 


# 9월 14일 찾아보고 공부할 것들
# try - except 이거 정리하기 
# def 함수 정의하는거 완벽하게 익히기
# 백준 4673번 익히기 ( 함수 => 정의를 깔끔하게 하는 것을 연습하기 )
=> 리스트나 튜블은 순서가 있기(ordered) 때문에 인덱싱을 통해 자료형 값을 얻을 수 있지만 set 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수는 없다. 
딕셔너리 역시 순서가 없는 자료형이라 인덱싱을 지원하지 않는다.
set 자료형에 저장된 값을 인덱싱으로 접근하려면 리스트나 튜플로 변환한 후 해야 한다.

# str의 정확한 의미를 알아야 할듯
for i in range(1, 10001):   # i = 850
    for j in str(i):        # j = "8" + "5" + "0"
        i += int(j)         # 850 + 8 + 5 + 0, i  = 863 (이게 내가 하려고 했던 것)
    generated_num.add(i)    # 생성자가 있는 숫자들 ##


generate_num.add(i) : 이것의 의미도 알아야 한다. # 생성자가 있는 숫자들
.add의 뜻이 무엇일까?

# for문 반복문에 i를 두번써도 상관이 없다.
# 어차피 각 반복문에 영향을 주지 않기 때문에 위에 반복문에서 for i in range쓰고 밑에도 for i 써도 상관이 없는듯

# 아스키 코드 : chr
print chr()

# 문자 -> 아스키 코드 : ord 
ex) print ord('A') : 65
ex) print odd ('C')

## 이런 방식으로도 생각해볼 수 있다. ##
n = input()
nums = input() # 공백없이 주어지니까 그냥 입력 받는다.
total = 0
for i in range(n):
    total += int(i) 
print(total)

### 이런 방식 ## 내가 원하던 것이 바로 int(nums[i])이런 것이없다.
n = int(input())
nums = int(input())
total = 0
for i in range(n):
    total += int(nums[i])  ### 이게 핵심 포인트 내가 원하는 것이 int(nums[i]) 이런거 같다..?!

print(total)


QQQQQ : 예를들어 nums로 123456789를 입력받았다.
nums[i]이런식으로 하면 nums[0] : 1 nums[1] : 2 이런 식으로 할당되나?